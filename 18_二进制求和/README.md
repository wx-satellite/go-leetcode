## 二进制求和（Add-Binary）
题干：
>给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。
示例 1:
&nbsp;&nbsp;输入: a = "11", b = "1"
&nbsp;&nbsp;输出: "100"
示例 2:
&nbsp;&nbsp;输入: a = "1010", b = "1011"
&nbsp;&nbsp;输出: "10101"
提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。
来源：力扣

解题思路与 [让我们一起啃算法----两数相加](https://learnku.com/articles/42985 "让我们一起啃算法----两数相加") 相似，只不过这里将链表换成了字符串，并且 **进位条件由大于等于 10 产生进位变成了 大于等于 2 产生进位**。

## 解题思路
首先要明确，一个 数字字符 与 字符0 相减，得到的值就是这个数字字符的数值，即 **'9' - '0' 等于 9**。

初始化 **i 指向字符串 a 的最后一个字符，j 指向字符串 b 的最后一个字符，res 为空字符串**，接着计算得到 **数值 a[i] 与 数值 b[j] 的和，记为 sum**。

如果 **sum 等于 2**，则产生进位 carry，且进位值为 1，如果 **sum 小于 2**，则不产生进位，carry 设置为 0。并将 **sum % 2** 的值转成字符串记为 **v**，与 **res** 进行拼接，由于我们是从右往左遍历的，每次计算得到的 **v** 应该与 **res** 左拼接，即 **res = v + res**。


接着 i 向左移动一位，b 向左移动一位，继续计算数值 a[i] 与 数值 b[j] 的和，**记得求和时带上上次的进位值**，重复上面的操作。

大致思路如上，详细流程，可以查看下面的流程图：

![](https://cdn.learnku.com/uploads/images/202004/27/21280/j4P8lNPsoN.jpg!large)



